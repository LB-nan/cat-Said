---
layout: post
title: Python线程
categories: Python
description: python线程
keywords: python线程
---

python线程相关

### 1、线程

线程是进程里的执行单位，进程是一个资源单位，一个内存空间的描述，相当于车间，进程是实际工作的，相当于流水线，流水线需要在车间里面，车间本身不干活，是流水线在干活。

每个进程至少都有一个线程，一个进程内可以有多个线程，线程执行过程中所需要的资源都去进程索要，同一个进程内的线程数据是共享的。

在一个进程内开设多个线程无需再次申请内存空间及拷贝代码的操作。

开设线程的开销要比开多进程小很多。

### 2、开启线程的两种方式

```py
from threading import Thread
from multiprocessing import Process


############   方式一   #####################################################
def task():
    print('1111')

# 开启线程
t = Thread(target=task)
t.start()
print('下一步')

############   方式二   #####################################################
class MyThread(Thread):
    def run(self):
        print('class')

if __name__ == '__main__':
    t = MyThread()
    t.start()
```

### 3、TCP使用线程实现并发

```py
import socket
from threading import Thread
from multiprocessing import Process

server = socket.socket()
server.bind(('127.0.0.1', 8080))

def talk(conn):
    while True:
      try:
        data = conn.recv(1024)
        if len(data) == 0: break
        conn.send(data.upper())
      except ConnectionResetError as e:
        break

while True:
    conn, addr = server.accept()
    # 开线程
    t = Thread(target=talk, args=(conn, ))
    t.start()



# 客户端代码
client = socket.socket()

client.connect(('127.0.0.1', 8080))

while True:
    client.send('hello')
    data = client.recv(1024)
    print(data.decode('utf-8'))
```

### 4、线程的join

```py
from threading import Thread
import time

def task():
    print('1111')


if __name__ == '__main__':
  t = Thread(target=task)
  t.start()
  t.join() # 主线程等待子线程结束之后再继续执行
  print('主')

```

### 5、同进程数据共享

同一个进程下的线程的数据是共享的

```py
from threading import Thread
import time

money = 100

def task():
    global money
    money = 11

if __name__ == '__main__':
  t = Thread(target=task)
  t.start()
  t.join()
  print(money)

```

### 6、线程的属性和方法

获取线程名

```py
from threading import Thread, current_thread

def task():
    print(current_thread().name)


# 开启线程
if __name__ == '__main__':

    t = Thread(target=task)
    t2 = Thread(target=task)
    t.start()
    t2.start()
    print(current_thread().name)


'''
Thread-1
Thread-2
MainThread
'''
```

统计当前活跃的线程数

```py
from threading import Thread, active_count
import time


def task():
    time.sleep(2)

# 开启线程
if __name__ == '__main__':

    t = Thread(target=task)
    t.start()

    t2 = Thread(target=task)
    t2.start()
    print(active_count())  # 3 
```

### 7、守护线程

主线程运行结束之后不会立刻结束，会等待其他所有的非守护子线程结束才会结束，因为主线程的结束意味着所在的进程结束。

```py
from threading import Thread
import time


def task():
    print('start') 
    time.sleep(2)
    print('over')

# 开启线程
if __name__ == '__main__':

    t = Thread(target=task)
    t.daemon = True
    t.start()
    print('2222222222222')
```
