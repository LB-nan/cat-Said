---
layout: post
title: Python线程
categories: Python
description: python线程
keywords: python线程
---

python线程相关

### 1、线程

线程是进程里的执行单位，进程是一个资源单位，一个内存空间的描述，相当于车间，进程是实际工作的，相当于流水线，流水线需要在车间里面，车间本身不干活，是流水线在干活。

每个进程至少都有一个线程，一个进程内可以有多个线程，线程执行过程中所需要的资源都去进程索要，同一个进程内的线程数据是共享的。

在一个进程内开设多个线程无需再次申请内存空间及拷贝代码的操作。

开设线程的开销要比开多进程小很多。

### 2、开启线程的两种方式

```py
from threading import Thread
from multiprocessing import Process


############   方式一   #####################################################
def task():
    print('1111')

# 开启线程
t = Thread(target=task)
t.start()
print('下一步')

############   方式二   #####################################################
class MyThread(Thread):
    def run(self):
        print('class')

if __name__ == '__main__':
    t = MyThread()
    t.start()
```

### 3、TCP使用线程实现并发

```py
import socket
from threading import Thread
from multiprocessing import Process

server = socket.socket()
server.bind(('127.0.0.1', 8080))

def talk(conn):
    while True:
      try:
        data = conn.recv(1024)
        if len(data) == 0: break
        conn.send(data.upper())
      except ConnectionResetError as e:
        break

while True:
    conn, addr = server.accept()
    # 开线程
    t = Thread(target=talk, args=(conn, ))
    t.start()



# 客户端代码
client = socket.socket()

client.connect(('127.0.0.1', 8080))

while True:
    client.send('hello')
    data = client.recv(1024)
    print(data.decode('utf-8'))
```

### 4、线程的join

```py
from threading import Thread
import time

def task():
    print('1111')


if __name__ == '__main__':
  t = Thread(target=task)
  t.start()
  t.join() # 主线程等待子线程结束之后再继续执行
  print('主')

```

### 5、同进程数据共享

同一个进程下的线程的数据是共享的

```py
from threading import Thread
import time

money = 100

def task():
    global money
    money = 11

if __name__ == '__main__':
  t = Thread(target=task)
  t.start()
  t.join()
  print(money)

```

### 6、线程的属性和方法

获取线程名

```py
from threading import Thread, current_thread

def task():
    print(current_thread().name)


# 开启线程
if __name__ == '__main__':

    t = Thread(target=task)
    t2 = Thread(target=task)
    t.start()
    t2.start()
    print(current_thread().name)


'''
Thread-1
Thread-2
MainThread
'''
```

统计当前活跃的线程数

```py
from threading import Thread, active_count
import time


def task():
    time.sleep(2)

# 开启线程
if __name__ == '__main__':

    t = Thread(target=task)
    t.start()

    t2 = Thread(target=task)
    t2.start()
    print(active_count())  # 3 
```

### 7、守护线程

主线程运行结束之后不会立刻结束，会等待其他所有的非守护子线程结束才会结束，因为主线程的结束意味着所在的进程结束。

```py
from threading import Thread
import time


def task():
    print('start') 
    time.sleep(2)
    print('over')

# 开启线程
if __name__ == '__main__':

    t = Thread(target=task)
    t.daemon = True
    t.start()
    print('2222222222222')
```

### 8、线程互斥锁

```py
from threading import Thread, Lock
import time

money = 100
mutex = Lock()

def task():
    global money
    mutex.acquire()
    tmp = money
    time.sleep(1)
    money = tmp - 1
    mutex.release()


if __name__ == "__main__":
    t_list = []
    for i in range(100):
        t = Thread(target=task)
        t.start()
        t_list.append(t)

    for t in t_list:
        t.join()
    
    print(money)

```

### 9、GIL 全局解释器锁

python解释器有多个版本

- Cpython
- Jpython
- Pypypython

但是普遍使用Cpython，在Cpython解释器中GIL是一把互斥锁，用来阻止同一个进程下的多个线程同时执行，就导致了同一个进程下的多个线程无法利用多核优势

因为cpython中的内存管理(垃圾回收机制/GC)不是线程安全的

- 因为垃圾回收机制是一条线程，而线程的执行不是有序的，如果线程可以多核运行，可能会出现垃圾回收机制线程优先抢到数据，然后GC发现这个变量没有被引用啊，直接给回收了，后续线程来了，人都麻了，没变量数据了。所以是不安全的，所以需要GIL

GIL的重点：

1. GIL不是python的特点而是Cpython解释器的特点
2. GIL是保证解释器级别的数据的安全
3. GIL会导致同一个进程下的多个线程的无法同时执行，即无法利用多核优势
4. 针对不同的数据还是需要加不同的锁处理
5. 解释性的语言的通病，同一个进程下的线程无法利用多核优势，因为解释器语言是解释一行代码执行一行代码，无法做到整体的编译完了之后再调整，每一行执行的时候不知道下一行会发生什么。

#### 9.1 GIL和普通互斥锁的区别

GIL无法保证数据的安全，只能保证垃圾回收机制的线程的安全，所以在操作数据的时候，还是需要额外加一把锁，当线程抢到GIL的时候，然后遇到IO释放，还可以通过自己的锁锁住，不会被别的线程抢走，从而导致数据错乱。

### 10、多进程与多线程

不考虑单核，因为单核都差不多。只考虑多核CPU的情况

1. IO密集型：在IO密集型的时候多线程耗时较短，因为节省了开进程的消耗。
2. 计算密集型：计算密集型里面多进程耗时较短，因为多个核肯定比一个核算的快。

实际中，通常是多进程里面开多线程。
