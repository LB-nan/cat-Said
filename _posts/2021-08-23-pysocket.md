---
layout: post
title: python socket
categories: Python
description: python socket
keywords: python socket
---

### 1、socket 套接字

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。

在TCP/IP五层协议里，除了应用层的行为需要自定义，其余四层（传输层、网络层、数据链路层、物理层）都已经封装成socket，只需要进行调用接口就好了。

### 2、使用

```py
import socket

# 创建socket
ms = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```

`socket.socket()`的第一个参数是套接字家族的类型，有两种

1. 基于文件类型的套接字家族：AF_UNIX
2. 基于网络类型的套接字家族：AF_INET

另外，还有AF_INET6被用于ipv6。

`socket.socket()`的第二个参数是使用什么协议，主要就两种

1. 流式，TCP协议： socket.SOCK_STREAM
2. 数据报文，UDP协议：socket.SOCK_DGRAM

#### 2.1 服务端套接字函数

`ms.bind()` 绑定(主机,端口号)到套接字
`ms.listen()` 开始TCP监听
`ms.accept()` 被动接受TCP客户的连接,(阻塞式)等待连接的到来

#### 2.2 客户端套接字函数

`ms.connect()` 主动初始化TCP服务器连接
`ms.connect_ex()` connect()函数的扩展版本,出错时返回出错码,而不是抛出异常

#### 2.3 公共的函数

`ms.recv()` 接收TCP数据
`ms.send()` 发送TCP数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完)
`ms.sendall()` 发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)
`ms.recvfrom()` 接收UDP数据
`ms.sendto()` 发送UDP数据
`ms.getpeername()` 连接到当前套接字的远端的地址
`ms.getsockname()` 当前套接字的地址
`ms.getsockopt()` 返回指定套接字的参数
`ms.setsockopt()` 设置指定套接字的参数
`ms.close()` 关闭套接字

#### 2.4 面向锁的函数

`ms.setblocking()` 设置套接字的阻塞与非阻塞模式
`ms.settimeout()` 设置阻塞套接字操作的超时时间
`ms.gettimeout()` 得到阻塞套接字操作的超时时间

#### 2.5 面向文件的函数

`ms.fileno()` 套接字的文件描述符
`ms.makefile()` 创建一个与该套接字相关的文件

### 3、基于TCP的套接字

一个demo

服务端代码

```py
import socket

# 创建socket
ms = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 绑定ip和端口
ms.bind(('127.0.0.1', 8080))

# 监听   backlog=5:半连接池的大小
ms.listen(5)

# 等待，获取一个连接
conn, client_addr=ms.accept()

print('conn', conn)
print('客户端的ip和端口：', client_addr)

# 收消息
data = conn.recv(1024)  # 最大接收量  1024字节
print(data.decode('utf-8'))
# 发消息
conn.send('服务端发的消息'.encode('utf-8'))

# 关闭连接
conn.close()

ms.close()

```

客户端代码

```py
import socket

# 创建socket  
ms  = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 客户端发请求给服务端
ms.connect(('127.0.0.1', 8080))

ms.send('客户端发送的消息'.encode('utf-8'))

data = ms.recv(1024)
print(data.decode('utf-8'))

ms.close()

```
