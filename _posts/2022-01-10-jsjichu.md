---
layout: post
title: 前端面试题之js基础
categories: 面试题
description: 面试题,js
keywords: 面试题, js,盒模型,布局,js,javascript,数据类型,类型转换,new,ES6
---

js面试常问知识点汇总

### 1、js中的数据类型

js种的数据类型分为：基础数据类型和复杂数据类型(对象类型/引用类型)

基础数据类型是存放在栈中，对象类型存放在堆中。

基础数据类型：

- 在ES3时代：
  - 有5种基础数据类型：undefined、null、Boolean、number、string
  - 一种对象类型：object；array、function都是对象类型
- 在ES6时代：基础数据类型新增了两种 symbol和bigint
  - symbol：代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。
  - BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。

### 2、数据类型检测

#### 2.1 typeof

```js
console.log(typeof 2);               // number
console.log(typeof true);            // boolean
console.log(typeof 'str');           // string
console.log(typeof []);              // object    
console.log(typeof function(){});    // function
console.log(typeof {});              // object
console.log(typeof undefined);       // undefined
console.log(typeof null);            // object
```

其中数组、对象、null都会被判断为object，其他判断都正确。

其中null判断为object是js遗留的问题，判断null的话可以`null == null`

#### 2.2 instanceof

instanceof只能判断引用类型，而不能判断基础类型，因为内部运行机制是顺着原型链查找该对象的原型

```js
console.log(2 instanceof Number);                    // false
console.log(true instanceof Boolean);                // false 
console.log('str' instanceof String);                // false 
 
console.log([] instanceof Array);                    // true
console.log(function(){} instanceof Function);       // true
console.log({} instanceof Object);                   // true
```

#### 2.3 constructor

constructor有两个作用，一是判断数据的类型，二是对象实例通过 `constrcutor` 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，`constructor`就不能用来判断数据类型了

```js
console.log((2).constructor === Number); // true
console.log((true).constructor === Boolean); // true
console.log(('str').constructor === String); // true
console.log(([]).constructor === Array); // true
console.log((function() {}).constructor === Function); // true
console.log(({}).constructor === Object); // true
```

### 3、箭头函数与普通函数的区别

1. 箭头函数没有自己的this
2. 箭头函数继承的this指向不可变，call()\bind()\apply()也不能改变
3. 箭头函数不能作为构造函数使用
4. 箭头函数没有arguments
5. 箭头函数没有prototype
6. 箭头函数不能用作generator函数，不能使用yeild关键字

### 4、proxy可以实现什么功能

proxy：`Proxy(target, handler)`

1. `target` ：需要使用`Proxy`包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。

2. `handler`: 一个对象，其属性是当执行一个操作时定义代理的行为的函数(可以理解为某种触发器)。可以进行get和set

在 Vue3.0 中通过 `Proxy+Reflect` 来替换原本的 `Object.defineProperty` 来实现数据响应式。

- vue3响应原理代码：`https://catsaid.cn/2020/04/20/vue3Proxy/`

### 5、new

new的执行过程：

1. 创建一个新的空对象
2. 设置原型，将对象的原型设置为函数的prototype对象
3. 让函数的this指向这个对象，执行构造函数代码
4. 判断函数的返回值类型，如果是值类型，就返回创建的对象，如果是引用类型，就返回引用类型的对象

```js
function createObject(n, ...args){
  let obj = {}
  Object.setPrototypeOf(obj, n.prototype)
  let result = n.apply(obj, args)
  return result instanceof Object ? result : obj;
}
```

### 6、原型、原型链

在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 **proto** 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。

当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。

因为原型链的存在，而JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。

原型修改：

```js
function Funa(){
  // ...
}

Funa.prototype.getName = function(){
  return 'a'
}

let fun = new Funa()
console.log(fun.getName())  // a
```

### 7、闭包

**闭包是指有权访问另一个函数作用域中变量的函数**，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

闭包的作用：

1. 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
2. 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

```js
function A() {
  let a = 1
  window.B = function () {
      console.log(a)
  }
}
A()
B() // 1
```

函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

经典面试题：循环中使用闭包解决 var 定义函数的问题

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}

// 解决方案一：使用闭包
for (var i = 1; i <= 5; i++) {  
  ;(function(j) {    
    setTimeout(function timer() {      
      console.log(j)    
    }, j * 1000)  
  })(i)
}
// 其他方案：使用setTimeout的第三个参数或使用let
```

### 8、作用域、作用域链

1. 全局作用域：
   1. 最外层函数和最外层函数外面定义的变量拥有全局作用域
   2. 所有未定义直接赋值的变量自动声明为全局作用域
   3. 所有window对象的属性拥有全局作用域
2. 函数作用域：
   1. 函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到
   2. 作用域是分层的，内层作用域可以访问外层作用域，反之不行
3. 块级作用域：
   1. 使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由`{ }`包裹的代码片段）
   2. 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。

作用域链：在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。

作用域链的作用：保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。

### 9、this

this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。

1. 函数调用：当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。
2. 方法调用：如果一个函数作为一个对象的方法来调用时，this 指向这个对象。
3. 构造器调用：如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。
4. apply、call、bind调用：这三个方法都可以改变this的指向，改变到哪里this值的就是谁

这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。

### 10、call、apply、bind

call和apply的区别他们的作用都一样，区别是传入参数的形式不同

- call(obj,args)：第一个参数是函数体的this的指向，第二个参数是一个带下标的集合，会传入函数体内，可以是数组或类数组
- Apply(obj, arg1, arg2.....)：第一个参数是函数体的this的指向，后续参数会依次传入函数体内

#### 10.1 实现call()

实现步骤：

1. 判断调用对象是否为函数
2. 判断传入上下文对象是否存在，如果不存在则设置为window
3. 处理参数，截取第一个参数后的所有参数
4. 将函数作为上下文对象的一个属性
5. 使用上下文对象来调用这个方法，并保存返回结果
6. 删除刚才新增的属性
7. 返回结果

实现代码：

```js
let obj = {
  name: 'a',
  fun: function(){
    console.log('a')
    return this.name
  }
}

let obj2 = {
  name: 'b',
  fun: function(){
    console.log('b')
    return this.name
  }
}

Function.prototype.myCall = function(context) {
  // 判断调用对象
  if (typeof this !== "function") {
    console.error("type error");
  }
  // 获取参数
  let args = [...arguments].slice(1),
      result = null;
  // 判断 context 是否传入，如果未传入则设置为 window
  // context = obj2
  context = context || window;
  console.log(context)
  // 将调用函数设为对象的方法
  // obj2.fn = obj.fun
  context.fn = this;
  console.log(context.fn.toString())
  // 调用函数
  // 这个时候obj的函数的this指向的是obj2了
  result = context.fn(...args);
  // 将属性删除
  delete context.fn;
  return result;
};

console.log(obj.fun.myCall(obj2) ,'2222')// b

/*
{ name: 'b', fun: [Function: fun] }
function(){
        console.log('a')
      return this.name
    }
a
b 2222
*/
```



