---
layout: post
title: Map、weakMap、Set、WeakSet
categories: javascript
description: 新的数据结构
keywords: JavaScript, Map, Set, 数据结构
---

ES6引入了四种新的数据结构：Map(映射)、Set(集合)、WeakSet(弱集合)和weakMap(弱映射)


> 首先，整理自阮一峰大佬的ES6书籍，原文还请移步：https://es6.ruanyifeng.com/#docs/set-map


### 1、Set

ES6 提供了新的数据结构 Set。

1. 它类似于数组，但是成员的值都是唯一的，没有重复的值。
2. 向`Set`加入值的时候，不会发生类型转换，所以`5`和`"5"`是两个不同的值。
3. 向`Set`加入值时认为NaN等于自身。
4. 另外，两个对象总是不相等的。
5. `Set`的遍历顺序就是插入顺序。
6. `Set`结构没有键名，只有键值（或者说键名和键值是同一个值）

`Set`本身是一个构造函数，用来生成 Set 数据结构。

```js
const set = new Set([1, 2, 3, 4, 4]);
[...set]  // [1,2,3,4]

// 2
const set = new Set([1, 2, 3, 4, '4']);
[...set] // [1, 2, 3, 4, "4"]

const set = new Set();
set.add(NaN)
set.add(NaN)
console.log(set) // Set { NaN }


let set = new Set();

set.add({});
console.log(set.size ) // 1

set.add({});
console.log(set.size ) // 2
```

#### 1.1 Set的属性和方法

属性：

1. `Set.prototype.constructor`：构造函数，默认是`Set`函数。
2. `Set.size`：返回`Set`实例的成员总数。

方法：

1. `Set.add(value)`：添加值
2. `Set.delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功
3. `Set.has(value)`：判断当前参数是否为`Set`的成员，返回一个布尔值
4. `Set.clear(value)`：清除所有值，没有返回值。
5. `Set.keys(value)`：返回键名的遍历器
6. `Set.values(value)`：返回键值的遍历器
7. `Set.entries(value)`：返回键值对的遍历器
8. `Set.forEach(value)`：使用回调函数遍历每个成员


#### 1.2 Set的使用

使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。
```js
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set {1, 2, 3, 4}

// 交集
let intersect = new Set([...a].filter(x => b.has(x)));
// set {2, 3}

// 差集
let difference = new Set([...a].filter(x => !b.has(x)));
// Set {1}
```

### 2、WeakSet

> WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。
> 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。
> 其次，WeakSet 中的对象都是弱引用,WeakSet 里面的引用，不计入垃圾回收机制的计数，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
> WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。


正确的例子：
```js
const a = [[1, 2], [3, 4]];
const ws = new WeakSet(a);
// WeakSet {[1, 2], [3, 4]}
```

错误的例子：
```js
const b = [3, 4];
const ws = new WeakSet(b);
// Uncaught TypeError: Invalid value used in weak set(…)
```
因为`WeakSet`的成员必须是对象。


属性和方法：
首先需要确定的是`WeakSet`没有`size`属性，也不能遍历。

1. `WeakSet.add(value)`：添加一个新成员。
2. `WeakSet.delete(value)`：删除一个成员。
3. `WeakSet.has(value)`：判断是否存在。




