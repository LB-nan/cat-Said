---
layout: post
title: promise
categories: javascript
description: promise
keywords: JavaScript, promise, 异步 
---


从0到1搞一哈promise


### 1、发布订阅 on-emit

发布订阅模式需要有一个`消息管理器`，发布者并不会直接去联系订阅者，他们之间有一个`中间人`来处理消息队列(函数)。 发布者和订阅者是解耦的。

```
  // 发布订阅
  let e = {
    arr: [],
    on(fn){
      this.arr.push(fn);
    },
    emit(){
      this.arr.forEach((fn) => fn());
    }
  }

  // 订阅
  e.on( ()=> {
    console.log('1');
  })

  // 发布
  function something (){
    e.emit();
  }

  something();
```

### 2、观察者模式 observer

发布订阅是观察者模式的一部分，观察者模式分两个角色，观察者和被观察者，被观察者状态发生改变之后通知自己身上的所有观察者更新状态。观察者和被观察者是有联系的。

```
  class Student {  // 被观察者
    constructor(){
      this.teachers = []; // 存放订阅/观察者
      this.state = '认真学习'; // 状态
    }
    attach(t){
      this.teachers.push(t);  // 订阅
    }
    setState(newState){
      this.state = newState;  // 修改被观察者的状态
      this.teachers.forEach((t) => t.update(newState)) // 被观察者的状态改变后通知观察者
    }
  }

  class Teacher {
    constructor(name){
      this.name = name
    }
    update(newState){
      console.log(this.name + '的学生' + newState + '了，要做某事了');
    }
  }


  let s = new Student();
  let t1 = new Teacher('张老师');
  let t2 = new Teacher('李老师');

  // 订阅, 把观察者放到被观察者身上去
  s.attach(t1);
  s.attach(t2);

  s.setState('谈恋爱');

  // 张老师的学生谈恋爱了，要做某事了
  // 李老师的学生谈恋爱了，要做某事了

```

### 3、promise

#### 3.1 promise的作用

> 1. 解决并发问题：同步获取多个异步的执行结果。
> 
> 2. 链式调用问题(多个回调嵌套)：下一个接口的参数依赖于上一个接口的返回值


#### 3.2 promise的使用

> 1. promise是一个类
> 
> 2. 每次new promise都需要传一个执行器函数，这个函数是立即实行的
> 
> 3. 执行器函数有两个参数 resolve(成功) reject(失败)
>
> 4. promise默认有三个状态, pending(等待) resolve(成功) reject(失败)
>
> 5. 状态一旦改变，不能再次改变，改变会被忽略。
> 
> 6. 每个promise都有`then`方法
> 
> 7. promise实例可以调用`then`方法去监控成功或者失败的回调(resolve or reject), 第一个参数是成功的回调，第二个参数是失败的回调。

```
  let p = new Promise((resolve, reject) => {
    // 只能是成功或者失败之一，因为状态一旦改变，不能再次改变。
    resolve('成功了');
    // reject('失败了');
  })

  p.then((data) => {
    console.log(data);
  }, (err) => {
    console.log(err);
  })

```








