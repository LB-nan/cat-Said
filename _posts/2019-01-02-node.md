---
layout: post
title: Node
categories: node
description: node简介
keywords: node, javascript
---

node.js入门笔记

先说JavaScript吧，JavaScript是由`ECMAScript/BOM/DOM`组成，ECMAScript定义了js的语法，结构，内置了一些对象，BOM是操控浏览器的一些API，DOM是操控网页的一些API。

node.js也是由ECMAScript为组成的，只不过额外扩展了一些别的功能，比如`OS/file/net/database..`

node.js是模块化的，各个文件都是独立的模块。

node.js和JavaScript语法差不多。

node异步方法的第一个参数是错误参数。


### 1、node.js模块引用
假设根目录有两个文件 a.js / b.js, a引用b的方法
```
  // a.js
  let bObj = require('./b.js')
  console.log(bObj.name); //张三

  // b.js
  var name = "张三";
  module.export = {
      name
  }
```

### 2、事件模块
node.js 提供了事件模块，可以让我们自己去注册事件，触发事件。发布订阅模式
有三点需要注意：
1. 大多数Node.js核心API都是采用惯用的异步事件驱动架构，例如fs/http；
2. 所有能触发事件的对象都是EventEmitter类的实例；
3. 事件流程：引入模块 -  创建EventEmitter对象 -  注册事件 -  触发事件

使用：

```
  // 引入
  let events = require('events');

  // 实例化一个事件对象
  let myEvent =new events.EventEmitter();

  // 注册事件
  myEvent.on('someEvent',  (agm) => {
    // 一些操作
    console.log('触发了someEvent');
    console.log(agm);
  })

  // 触发事件
  myEvent.emit('someEvent','hello someEvent');
```

#### 2.1 简单原理实现

```
function EventEmitter(){
    this._events = Object.create(null);
}

EventEmitter.prototype.on = function(eventName,callback){
    // 如果有，就用，没有就赋值一个
    if(!this._events) this._events = Object.create(null);
    if(this._events[eventName]){
        this._events[eventName].push(callback);
    }else{
        this._events[eventName] = [callback];
    }
}

EventEmitter.prototype.emit= function(eventName,...args){
    if(this._events[eventName]){
        this._events[eventName].forEach(fn => fn(...args));
    }
}

```


### 3、文件系统 file system
node.js可以对文件进行读写、创建删除操作，使用的模块是fs模块，方法是同步+异步的。
使用：读写文件，读取文件，文件不存在会报错，写入文件，文件不存在会创建。

```
  let fs = require('fs');

  // 文件a.txt
  老酒馆的猫

  // 同步读取文件
  var file = fs.readFileSync('a.txt', 'utf8'); 
  console.log(readFile);

  // 同步写入文件，写入默认的是utf8
  fs.writeFileSync('write.txt', file );

  // 异步读取文件
  fs.readFile('a.txt', 'utf8', function(err, data){
    // callback
    if (err) throw err;

    console.log(data);
  })
  // 异步写入是同样的，去掉 Sync  第三个参数是callback


  // 创建文件夹  同步or异步
  fs.mkdirSync('stuff');
  fs.mkdir('stuff', callback);

  // 删除文件夹  同步or异步
  // 删除文件夹需要先删除文件夹内的文件，然后再删除文件夹;
  fs.rmdirSync('stuff');
  fs.rmdir('stuff', callback);

  // 删除文件
  fs.unlink('a.txt', callback); // 参数是路径, callback的参数是err
```

`fs.readFile`不适合大文件(一般指64K以上)来使用，否则可能会导致内存浪费，大文件使用数据流读取或使用buffer结合使用fs的其他方法读，`fs.open`打开文件,`fs.read`读取文件 `fs.write`写入文件 `fs.close`关闭文件。


#### 3.1 分步读取

fs.open(file，flags，cb): file是文件的路径；flags是读写； cb是回调，有两个参数，`err, fd`，fd代表文件。 
fs.open() 不进入同步阻塞调用。如果你想，则应该使用 fs.openSync()。  

-  flags可以是：
-  1. `r`：以读取模式打开文件。如果文件不存在则发生异常。
-  2. `r+` 以读写模式打开文件。如果文件不存在则发生异常。
-  3. `rs+` 以同步读写模式打开文件。命令操作系统绕过本地文件系统缓存。
-  4. `w` 以写入模式打开文件。文件会被创建（如果文件不存在）或截断（如果文件存在）。
-  5. `w+` 在写的基础上，读取，如果不存在会创建。
-  6. `wx` 类似 `w`，但如果 path 存在，则失败。
-  7. `wx+` 类似 `w+`，但如果 path 存在，则失败。
-  8. `a` 以追加模式打开文件。如果文件不存在，则会被创建。
- 9. `ax` 类似于 ‘a’，但如果 path 存在，则失败。
- 10. `a+` 以读取和追加模式打开文件。如果文件不存在，则会被创建。
- 11. `ax+` 类似于 ‘a+’，但如果 path 存在，则失败。
  

```
let buffer = Buffer.alloc(3);
fs.open('./file1.txt', 'r', (err, fd)=>{
  // 把读到的文件写到buffer里面去
  // 打开要写入的文件，然后开始写
  fs.open('./target.txt', 'w', (err, wfd)=>{
    fs.read(fd, buffer, 0, 3, 0, function(err){
      fs.closeSync(fd, ()=>{
        console.log('关闭');
      });
    })
  })
})
```
这种方式很不科学，耦合性很高，解耦可以用发布订阅模式解耦，fs模块针对这种情况产生了一个流的方法，下面会说到。


### 4、服务器

```
  // 引入HTTP模块
  var http = require('http');

  // 创建服务器  
  var server = http.createServer((req, res) => {
    console.log('客户端发送请求:' + req.url)
    //  设置请求头
    res.writeHead(200, {
      "Content-type": "text-plain"
    });

    // 返回数据
    res.end('server is working');
  })

  // 监听端口请求
  server.listen(8888, '127.0.0.1');
```

Content-type的值：
```
  text/html ： HTML格式
  text/plain ：纯文本格式
  ext/xml ： XML格式
  image/gif ：gif图片格式
  image/jpeg ：jpg图片格式
  image/png：png图片格式
  application/xhtml+xml ：XHTML格式
  application/xml ： XML数据格式
  application/atom+xml ：Atom XML聚合格式
  application/json ： JSON数据格式
  application/pdf ：pdf格式
  application/msword ： Word文档格式
  application/octet-stream ： 二进制流数据（如常见的文件下载）
  application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）
  multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式
```

### 5、数据流 & buffer
node.js读取数据流有一个缓存区，需要先了解`buffer`，node.js读取数据不是一次性全部读取出来的，数据量很大的情况下，会分批次读取，每次读取的一些东西存到buffer里面，然后再发送流，然后接着读取。

```
  var fs = require('fs');
  // 读取数据流对象 
  var myReadStream = fs.createReadStream(__dirname + '/readMe.txt', 'utf8');
  // 写入数据流对象
  var myWriteStream = fs.createWriteStream(__dirname + '/writeMe.txt');
  // 读取文件的事件， 每一个streame都是EventEmitter的实例
  var count = 0;
  myReadStream.on('data', function(chunk){
    count++;
    console.log(count); // 1 2 3 4 
    console.log(chunk);  // 每次读取到的部分数据

    // 写入数据流
    myWriteStream.write(chunk)
  })
```
写入数据流的时候有一个pipe事件，可以控制数据写到哪里，使用pipe事件来重新修改上面的代码

```
  var fs = require('fs');
  // 读取数据流对象 
  var myReadStream = fs.createReadStream(__dirname + '/readMe.txt', 'utf8');
  // 写入数据流对象
  var myWriteStream = fs.createWriteStream(__dirname + '/writeMe.txt');
  // 写入操作
  myReadStream.pipe(myWriteStream); 
```
会发现使用pipe很方便，可以写入文件里面，自然可以写入到页面里面去

```
  var fs = require('fs');
  var http = require('http');
  // 创建服务器
  var server = http.createServer(function (req, res) {
    res.writeHead(200, {"Content-type": "text/plain"})
    // 读取数据流对象 
    var myReadStream = fs.createReadStream(__dirname + '/readMe.txt', 'utf8');

    // 写入操作
    myReadStream.pipe(res)
  })

  // 监听
  server.listen(8888, '127.0.0.1');
```

既然可以读取纯文本就可以读取HTML 、 json

```
  // html
  res.writeHead(200, {"Content-type": "text/html"})
  // 读取数据流对象 
  var myReadStream = fs.createReadStream(__dirname + '/index.html', 'utf8');

  // json
  res.writeHead(200, {"Content-type": "application/json"})
  // 读取数据流对象 
  var myReadStream = fs.createReadStream(__dirname + '/json.json', 'utf8');
```

#### 5.1 buffer 缓冲器

buffer主要就是用在fs中，buffer就是把二进制表现成了10进制，可以和字符串无条件转化。 buffer代表了内存，不能扩展，需要有一个固定大小。

buffer和数组很类似，`buffer[0]`取值

使用方法：`Buffer.alloc`、`Buffer.allocUnsafa`
```
  let buf = Buffer.alloc(10); //申请10个内存

  let buf2 = Buffer.allocUnsafe(10); // 抓取10个内存，可能还没来得及释放，不安全
  buf2.fill(0);  // 填充，手动擦除内存

  let buf3 = Buffer.from('buffer'); // 字符串填充，不可变。

```

常用的方法：

1. buf.slice()：截取值，和数组的类似。
2. Buffer.isBuffer(buf)：判断是不是buffer，和数组的isArray一样。
3. copy(targetBuffer,targetStratIndex, sourceStartIndex, sourceEndIndex)：拷贝buffer，buf1.copy(buf2,0,1,3);
4. buf.toString()：转化成字符串，可以设置进制数或者base64、utf8
5. buf.concat()：拼接，和数组的类似。`let newBuffer = Buffer.concat(bf1, bf2,10)`; 第三个参数为buffer的大小，如果不填则默认bf1+bf2的长度。
6. buf.fill()：填充。
7. Buffer.from('any')：给buffer直接创建一个值。
8. Buffer.indexOf()：查找某一个值的索引。


```
// copy原理
Buffer.prototype.copy = function(targer, targetIndex, sourceStrat=0, sourceEnd=this.length){
  for(let i = 0; i<sourceEnd-sourceStrat; i++){
    targer[targetIndex+i] = this[sourceStrat+i];
  }
}

// concat
Buffer.concat = function(list, length = list.reduce( (a,b)=> a+b.length,0 )){
  let buff = Buffer.alloc(length);
  let count = 0;
  list.forEach(item => {
    b.copy(item, count);
    count += item.length;
  });
  return buff;
}
```

### 6、路由
路由和vue里面的差不多，甚至更简化。在服务器里面的回调函数里面有两个参数，req, res, 我们可以获取req.url来获取路由。然后判断路由返回不同的HTML文件

```
    if(req.url === '/'){
      // ... 
      res.writeHead(200, {"Content-type": "text/html"})
      fs.createReadStream(__dirname + '/index.html').pipe(res);
    } else if(req.url === '/contact'){
      // ...
      res.writeHead(200, {"Content-type": "text/html"})
      fs.createReadStream(__dirname + '/home.html').pipe(res);
    }
```

### 7、NPC 包管理器
NPM是随同nodeJs一起安装的包管理工具，能解决node代码部署上的很多问题。

常见的使用场景：
1、允许用户从NPM服务器下载别人编写的第三方包到本地使用。
2、允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。
3、允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。

使用：
1、 需要使用NPM 安装一个东西的时候，必须有一个文件为 package.json, package用于定义项目中所需要的各种模块，以及项目的配置信息，比如名称、版本、许可证等元数据。
2、创建或安装 package.json文件
```
  npm init
```

然后会有一系列的设置，默认都回车，有特殊需要的特殊设置，需要注意的是项目的名字不允许有大写。
3、 安装各种插件或者库
```
  npm install xxx  --save
```

4、 卸载某一个插件或者库
```
  npm uninstall xxx
```

5、详细的看另一篇：<https://catsaid.cn/2019/12/06/npm/>

### 8、express框架
基于node.js平台，快速，开放，极简的web开发框架。

安装
```
  npm install express --save
```


