---
layout: post
title: loader
categories: tools
description: webpack loader
keywords: webpack4, 前端工程化, loader 
---

webpack loader

### 1、loader

webpack只能处理JavaScript的模块，如果要处理其他类型的文件就需要使用loader进行转换。

loader是webpack中一个重要的概念，它是指用来将一段代码转换成另一段代码的webpack加载器。

### 2、一个简易loader

初始化一个npm项目，安装webpack，配置`webpack.config.js`

```js
let path = require('path');

module.exports = {
  mode: 'development',
  entry: "./src/index.js",
  output: {
    filename: "build.js",
    path: path.resolve(__dirname, 'dist')
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: path.resolve(__dirname, 'loaders','jsLoader.js')
      }
    ]
  }
}


// 加载loader还可以通过配置resolveLoader 别名alias的配置，不需要在配置loader的地方写path.resolve(__dirname, 'loaders','jsLoader.js') 这么长的内容
let path = require('path');
module.exports = {
  mode: 'development',
  entry: "./src/index.js",
  output: {
    filename: "build.js",
    path: path.resolve(__dirname, 'dist')
  },
  resolveLoader: {
    alias: {
      myJsLoader: path.resolve(__dirname, 'loaders', 'jsLoader.js')
    }
  },
  module: {
    rules: [{
      test: /\.js$/,
      use: 'myJsLoader'
    }]
  }
}

// 还可以配置成自己寻找  配置modules，设置如果`node_modules`里面找不到就去`./loaders`里面找，这样就可以自动寻找我们自定义的loader了
module.exports = {
  mode: 'development',
  entry: "./src/index.js",
  output: {
    filename: "build.js",
    path: path.resolve(__dirname, 'dist')
  },
  resolveLoader: {
    modules: ['node_modules', path.resolve(__dirname, 'loaders')]
  },
  module: {
    rules: [{
      test: /\.js$/,
      use: 'jsLoader'
    }]
  }
}
```

加载一个我们自己的loader，在`/loaders/jsLoader.js`

```js
function loader(source){
  return source;
}

module.exports = loader;
```

loader就是一个函数，接受一个参数，参数是源代码，多个loader的时候从下自上依次执行，前面执行的loader的返回值是下一个loader执行的参数。

输入以上代码执行`npx webpack`打包，`dist`目录内的`build.js`内容如下

```js
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (() => {

eval("console.log('loader 1 转换的js');\n\n//# sourceURL=webpack://loader/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.js"]();
/******/ 	
/******/ })()
;
```

会发现源代码会被`eval()`方法包裹。

这就是一个简易的loader了

### 3、配置多个loader

多个loader的执行顺序默认是 从下到上，从右到左。

先创建多个loader

```js

// loaders/loader2.js
function loader(source) {
  source =  source.replace(/loader1/, 'loader2')
  return source;
}

module.exports = loader;



// loaders/loader3.js
function loader(source) {
  source = source.replace(/loader2/, 'loader3')
  return source;
}

module.exports = loader;

```

修改`webpack.config.js`的配置，可以加载多个loader

```js
module.exports = {
  resolveLoader: {
    modules: ['node_modules', path.resolve(__dirname, 'loaders')]
  },
  module: {
    rules: [{
      test: /\.js$/,
      use: [
        'loader3',
        'loader2',
        'jsLoader'
      ]
    }]
  }
}
```

然后运行`npx webpack`来看结果, 打开`dist/build.js`运行代码后输出

```text
loader3 转换的js
```

可以发现loader的确是从右到左从下到上执行的，而且前面loader的返回值是后面loader的参数。
